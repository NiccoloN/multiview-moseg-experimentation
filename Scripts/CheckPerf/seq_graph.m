% -------------------------------------------------------------------------
% Generation of sequence-dependent error graphs, for the selected alpha,
% lambda and gamma
% -------------------------------------------------------------------------
% This function reads the error matrix generated by error_analisys() and
% creates graphs of the errors for all the six methods, creating a plot
% function of the sequences
% For CoReg and Subset, a specific value of lambda and gamma parameters has
% to be chosen
% 
% The required parameters are:
% Error_matrix: the error matrix generated by error_analisys()
% alpha_range: array of values of alpha
% lambda_range: array of values of lambda
% gamma_range: array of values of gamma
% sel_alpha: chosen alpha parameter
% sel_lambda: chosen lambda parameter
% sel_gamma: chosen gamma parameter
% seq_range: sequences studied
% 
% Warning: alpha_range, lambda_range, gamma_range must be the same ranges
% used to generate both the results and the Error_matrix
% Warning: sel_lambda and sel_gamma have to be elements of lambda_range and
% gamma_range, respectively

function seq_graph(Error_matrix, Clusters_matrix, alpha_range, lambda_range, gamma_range, sel_alpha, sel_lambda, sel_gamma, sel_seqs, run_parameters)

    methods = {'Affine', 'Homography', 'Fundamental', 'KerAdd', 'CoReg', 'Subset'};
    colors = colormap(figure('Visible', 'off'), lines(length(methods)));

    sel_lambda_ind = lambda_range == sel_lambda;
    sel_gamma_ind = gamma_range == sel_gamma;

    Averaged_matrix = mean(Error_matrix, 1);

    % Open a new figure
    fig = figure;
    % set(gca, 'Color', [0.8 0.8 0.8]); % Light gray color background
    legend_entries = methods;
    legend_entries{length(methods) + 1} = "MajVotingSingle";
    legend_entries{length(methods) + 2} = "MajVotingAll";

    % Get the default width and height of the figure in pixels
    normalWidth = 560; % Default width of a figure in pixels
    normalHeight = 670; % Default height of a figure in pixels
    
    % Get the screen size
    screenSize = get(0, 'ScreenSize');
    
    % Calculate the center position for the figure window
    centerX = (screenSize(3) - 3*normalWidth) / 2;
    centerY = (screenSize(4) - normalHeight) / 2;
    
    % Set the figure's position and size
    set(fig, 'Position', [centerX, centerY, 3*normalWidth, normalHeight]);

    % Load ground truth
    seq_list_file = load(fullfile("Datasets", run_parameters.sel_dataset, "SeqList.mat"));
    seq_list = seq_list_file.SeqList;
    ground_truth_list = cell(1, length(sel_seqs));
    for seq_ind = 1:length(sel_seqs)
        seq_name = seq_list{sel_seqs(seq_ind)};
        seq_data_file = load(fullfile("Datasets", run_parameters.sel_dataset, sprintf("%s.mat", seq_name)));
        ground_truth_list{seq_ind} = seq_data_file.Data.GtLabel;
    end
    
    % Plot the graphs
    for method_ind = 1:length(methods)
        sel_alpha_ind = alpha_range == sel_alpha(method_ind);
        Averaged_matrix_seq(:, method_ind) = squeeze(Averaged_matrix(1, method_ind, sel_seqs, ...
            sel_alpha_ind, sel_lambda_ind, sel_gamma_ind));
    end

    num_runs = size(Clusters_matrix, 1);

    for seq_ind = 1:length(sel_seqs)
        errors = zeros(1, num_runs);
        for run_ind = 1:num_runs
            Clusters = [];
            for method_ind = 1:length(methods)
                sel_alpha_ind = alpha_range == sel_alpha(method_ind);
                Clusters(:, method_ind) = Clusters_matrix{run_ind, method_ind, seq_ind, ...
                    sel_alpha_ind, sel_lambda_ind, sel_gamma_ind};
            end

            num_points = size(Clusters, 1);
            majvoting_all_cluster = zeros(num_points, 1);
            majvoting_single_cluster = zeros(num_points, 1);
            for i = 1:num_points
                method_labels = Clusters(i, :);
                [count, values] = hist(method_labels, unique(method_labels));
                [~, argmax] = max(count);
                majvoting_all_cluster(i) = values(argmax);


                method_labels = Clusters(i, 1:3);
                [count, values] = hist(method_labels, unique(method_labels));
                [~, argmax] = max(count);
                majvoting_single_cluster(i) = values(argmax);
            end

            majvoting_all_errors(run_ind) = Misclassification(majvoting_all_cluster, ground_truth_list{seq_ind});
            majvoting_single_errors(run_ind) = Misclassification(majvoting_single_cluster, ground_truth_list{seq_ind});
        end

        Averaged_matrix_seq(seq_ind, length(methods) + 1) = 0;
        Averaged_matrix_seq(seq_ind, length(methods) + 2) = 0;
        Averaged_matrix_seq(seq_ind, length(methods) + 1) = mean(majvoting_single_errors);
        Averaged_matrix_seq(seq_ind, length(methods) + 2) = mean(majvoting_all_errors);
    end

    Averaged_matrix_seq(length(sel_seqs) + 1, :) = mean(Averaged_matrix_seq(1:length(sel_seqs), :), 1);
    Averaged_matrix_seq(length(sel_seqs) + 2, :) = median(Averaged_matrix_seq(1:length(sel_seqs), :), 1);
    
    ax = bar(100*Averaged_matrix_seq, 'hist');
    set(gca, "FontSize", 15)
    xlabels = [string(sel_seqs), 'average', 'median'];
    xticks(1:length(xlabels));
    xticklabels(xlabels);
    
    xlabel('sequences');
    ylabel('error (%)');
    ylim([0, 50]);

    grid(gca, 'minor');
    legend(legend_entries);

    title(sprintf('Dataset: %s\nORK %s evaluated using %s method\nClustering: %s\nFrame gap: up to %d frames', run_parameters.sel_dataset, run_parameters.ork_philosophy, run_parameters.ork_method, run_parameters.clustering_method, run_parameters.frame_gap_range))

end